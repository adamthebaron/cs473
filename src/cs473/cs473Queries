    /**
     * DONE
     * Returns all flights between the two airports on a given date. Note that I have simplified this from the
     * original requirements that specified a date range.  This function returns a generic Object so you can return
     * any object type that makes sense for your data model. The class your return should override the toString() method
     * and print something useful. Look at the sample Airline object for an example of this.
     */
     db.FlightQuery.find(
        { $and: [
            { "fromAirport" : },
            { "toAirport" : },
            { "dayOfWeek" : }
        ]}
        ).pretty()


    /**
     * NOT DONE
     * Returns all flights that are overbooked on the given day at the airport in question. If the boolean
     * checkOriginationCity is true, then you should check flights leaving the airport on the day. If the value is
     * false then you should check flight arriving at the airport that day. I have simplified this to a single date
     * instead of a date range.
     */
    public List<FlightQuery> flightOverbooked(boolean checkOriginationCity, String airportCode, Date date) {
        List<FlightQuery> returnStuff = new ArrayList<>();
        SimpleDateFormat dateFormat = new SimpleDateFormat("EEEE");
        Query<FlightQuery> querya = datastore.createQuery(FlightQuery.class);
        if (checkOriginationCity)
            querya.field("fromAirport").equal(airportCode)
                  .field("day").equal(dateFormat.format(date));
        else
            querya.field("toAirport").equal(airportCode)
                  .field("day").equal(dateFormat.format(date));
        List<FlightQuery> flights = querya.asList();
        for (FlightQuery flight: flights) {
            String flightCode = flight.number;
            Query<TravellerQuery> queryb = datastore.createQuery(TravellerQuery.class);
            queryb.field("flights.flightCode").equal(flightCode);
            List<TravellerQuery> reservations = queryb.asList();
            if (reservations.size() > flight.seats)
                returnStuff.add(flight);
        }
        return returnStuff;
    }

    /**
     * DONE
     * Returns the airport code of the airport with the highest demand on the given date. Note that this clarifies
     * the original requirements and should return an individual airport and not a city, which may have multiple
     * airports. This also limits the require to only a date and not a day or week.
     *
     * Demand is to be calculated as the percentage of possible seats originating at the airport that are sold.
     */
     db.Reservation.aggregate([
       { $match: {
           dayOfWeek:
         }
       },
       { $group: {
           _id: "$flight",
           reservations: {
             $push: { _id: "$_id" }
           }
         }
       },
       { $project: {
           flight: "$_id",
           Reservations: {$size: "$reservations"}
         }
       },
       { $lookup: {
           from: "FlightQuery",
           localField: "flight",
           foreignField: "_id",
           as: "flight_info"
         }
       },
       {
        $unwind: "$flight_info"
       },
       { $project: {
          reservations: "$Reservations",
          seats: "$flight_info.seats",
          flight: "$flight"
         }
       },
       { $project: {
           demand: {
              $divide: ["$reservations", "$seats"]
           }
         }
       },
       { $project: {
           demand: {
               $multiply: ["$demand", 100]
           }
         }
       },
       {
        $sort: { demand: 1 }
       }
       ]).pretty()


    /**
     * DONE
     * Same as above with two changes. First this provides a day of week instead of a single date. This means you have
     * to look at all flights on that day of week, not just on an individual date. This is thus covering many more
     * flights. This is also looking for the lowest demand, computed with the same definition as above.
     */
     db.Reservation.aggregate([
       { $match: {
           dayOfWeek: 2
         }
       },
       { $group: {
           _id: "$flight",
           reservations: {
             $push: { _id: "$_id" }
           }
         }
       },
       { $project: {
           flight: "$_id",
           Reservations: {$size: "$reservations"}
         }
       },
       { $lookup: {
           from: "FlightQuery",
           localField: "flight",
           foreignField: "_id",
           as: "flight_info"
         }
       },
       {
        $unwind: "$flight_info"
       },
       { $project: {
          reservations: "$Reservations",
          seats: "$flight_info.seats",
          flight: "$flight"
         }
       },
       { $project: {
           demand: {
              $divide: ["$reservations", "$seats"]
           }
         }
       },
       { $project: {
           demand: {
               $multiply: ["$demand", 100]
           }
         }
       },
       {
        $sort: { demand: -1 }
       }
       ]).pretty()

    /**
     * DONE
     * Returns the airport code for the airport with the most available seats on a given date. Once again I have
     * simplified to a single date from a range and are requesting a single airport instead of a city. This may be a
     * different airport than the one with the lowest demand.
     */
     db.Reservation.aggregate([
       { $match: {
           dayOfWeek:
         }
       },
       { $group: {
           _id: "$flight",
           reservations: {
             $push: { _id: "$_id" }
           }
         }
       },
       { $project: {
           flight: "$_id",
           Reservations: {$size: "$reservations"}
         }
       },
       { $lookup: {
           from: "FlightQuery",
           localField: "flight",
           foreignField: "_id",
           as: "flight_info"
         }
       },
       {
        $unwind: "$flight_info"
       },
       { $project: {
          reservations: "$Reservations",
          seats: "$flight_info.seats",
          flight: "$flight"
         }
       },
       { $project: {
           availableSeats: {
              $subtract: ["$seats", "$reservations"]
           }
         }
       },
       {
        $sort: { availableSeats: -1 }
       },
       { $limit: 1 }
       ]).pretty()

    /**
     * CANT DO
     * For this query you are going to return a map of maps. The outmost map will have as keys the airline codes. Each
     * entry in this map will map a day of week (integers 0 - 6) to the number of miles flown.
     */
    public Map<String, Map<Integer, Integer>> totalMilesAnalysis() {
        return null;
    }

    /**
     * CANT DO
     * This is a simplified version of the query in the original documentation. You simply need to give the
     * average miles flown by the 100 travellers with the most miles flown all time.
     */
    public int top100TravellerMiles() {
        return 0;
    }

    /**
     * This function will get the day of week for a date. It has to subtract one from the value returned from c.get(...)
     * because Java calendar uses 1 for Sunday, 2 for Monday and our data starts at 0 for Sunday.
     * ref: http://stackoverflow.com/questions/5270272/how-to-determine-day-of-week-by-passing-specific-date
     */
    private int dayOfWeek(Date date) {
        Calendar c = Calendar.getInstance();
        c.setTime(date);
        return c.get(Calendar.DAY_OF_WEEK) - 1;
    }


}
